// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'specialties_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SpecialtiesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Specialty> data) loaded,
    required TResult Function(Failure failure) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpecialtiesStateInitial value) initial,
    required TResult Function(SpecialtiesStateLoading value) loading,
    required TResult Function(SpecialtiesStateLoaded value) loaded,
    required TResult Function(SpecialtiesStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecialtiesStateCopyWith<$Res> {
  factory $SpecialtiesStateCopyWith(
          SpecialtiesState value, $Res Function(SpecialtiesState) then) =
      _$SpecialtiesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SpecialtiesStateCopyWithImpl<$Res>
    implements $SpecialtiesStateCopyWith<$Res> {
  _$SpecialtiesStateCopyWithImpl(this._value, this._then);

  final SpecialtiesState _value;
  // ignore: unused_field
  final $Res Function(SpecialtiesState) _then;
}

/// @nodoc
abstract class _$$SpecialtiesStateInitialCopyWith<$Res> {
  factory _$$SpecialtiesStateInitialCopyWith(_$SpecialtiesStateInitial value,
          $Res Function(_$SpecialtiesStateInitial) then) =
      __$$SpecialtiesStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpecialtiesStateInitialCopyWithImpl<$Res>
    extends _$SpecialtiesStateCopyWithImpl<$Res>
    implements _$$SpecialtiesStateInitialCopyWith<$Res> {
  __$$SpecialtiesStateInitialCopyWithImpl(_$SpecialtiesStateInitial _value,
      $Res Function(_$SpecialtiesStateInitial) _then)
      : super(_value, (v) => _then(v as _$SpecialtiesStateInitial));

  @override
  _$SpecialtiesStateInitial get _value =>
      super._value as _$SpecialtiesStateInitial;
}

/// @nodoc

class _$SpecialtiesStateInitial implements SpecialtiesStateInitial {
  const _$SpecialtiesStateInitial();

  @override
  String toString() {
    return 'SpecialtiesState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecialtiesStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Specialty> data) loaded,
    required TResult Function(Failure failure) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpecialtiesStateInitial value) initial,
    required TResult Function(SpecialtiesStateLoading value) loading,
    required TResult Function(SpecialtiesStateLoaded value) loaded,
    required TResult Function(SpecialtiesStateError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class SpecialtiesStateInitial implements SpecialtiesState {
  const factory SpecialtiesStateInitial() = _$SpecialtiesStateInitial;
}

/// @nodoc
abstract class _$$SpecialtiesStateLoadingCopyWith<$Res> {
  factory _$$SpecialtiesStateLoadingCopyWith(_$SpecialtiesStateLoading value,
          $Res Function(_$SpecialtiesStateLoading) then) =
      __$$SpecialtiesStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpecialtiesStateLoadingCopyWithImpl<$Res>
    extends _$SpecialtiesStateCopyWithImpl<$Res>
    implements _$$SpecialtiesStateLoadingCopyWith<$Res> {
  __$$SpecialtiesStateLoadingCopyWithImpl(_$SpecialtiesStateLoading _value,
      $Res Function(_$SpecialtiesStateLoading) _then)
      : super(_value, (v) => _then(v as _$SpecialtiesStateLoading));

  @override
  _$SpecialtiesStateLoading get _value =>
      super._value as _$SpecialtiesStateLoading;
}

/// @nodoc

class _$SpecialtiesStateLoading implements SpecialtiesStateLoading {
  const _$SpecialtiesStateLoading();

  @override
  String toString() {
    return 'SpecialtiesState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecialtiesStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Specialty> data) loaded,
    required TResult Function(Failure failure) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpecialtiesStateInitial value) initial,
    required TResult Function(SpecialtiesStateLoading value) loading,
    required TResult Function(SpecialtiesStateLoaded value) loaded,
    required TResult Function(SpecialtiesStateError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class SpecialtiesStateLoading implements SpecialtiesState {
  const factory SpecialtiesStateLoading() = _$SpecialtiesStateLoading;
}

/// @nodoc
abstract class _$$SpecialtiesStateLoadedCopyWith<$Res> {
  factory _$$SpecialtiesStateLoadedCopyWith(_$SpecialtiesStateLoaded value,
          $Res Function(_$SpecialtiesStateLoaded) then) =
      __$$SpecialtiesStateLoadedCopyWithImpl<$Res>;
  $Res call({List<Specialty> data});
}

/// @nodoc
class __$$SpecialtiesStateLoadedCopyWithImpl<$Res>
    extends _$SpecialtiesStateCopyWithImpl<$Res>
    implements _$$SpecialtiesStateLoadedCopyWith<$Res> {
  __$$SpecialtiesStateLoadedCopyWithImpl(_$SpecialtiesStateLoaded _value,
      $Res Function(_$SpecialtiesStateLoaded) _then)
      : super(_value, (v) => _then(v as _$SpecialtiesStateLoaded));

  @override
  _$SpecialtiesStateLoaded get _value =>
      super._value as _$SpecialtiesStateLoaded;

  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$SpecialtiesStateLoaded(
      data: data == freezed
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<Specialty>,
    ));
  }
}

/// @nodoc

class _$SpecialtiesStateLoaded implements SpecialtiesStateLoaded {
  const _$SpecialtiesStateLoaded({required final List<Specialty> data})
      : _data = data;

  final List<Specialty> _data;
  @override
  List<Specialty> get data {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'SpecialtiesState.loaded(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecialtiesStateLoaded &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_data));

  @JsonKey(ignore: true)
  @override
  _$$SpecialtiesStateLoadedCopyWith<_$SpecialtiesStateLoaded> get copyWith =>
      __$$SpecialtiesStateLoadedCopyWithImpl<_$SpecialtiesStateLoaded>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Specialty> data) loaded,
    required TResult Function(Failure failure) error,
  }) {
    return loaded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
  }) {
    return loaded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpecialtiesStateInitial value) initial,
    required TResult Function(SpecialtiesStateLoading value) loading,
    required TResult Function(SpecialtiesStateLoaded value) loaded,
    required TResult Function(SpecialtiesStateError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class SpecialtiesStateLoaded implements SpecialtiesState {
  const factory SpecialtiesStateLoaded({required final List<Specialty> data}) =
      _$SpecialtiesStateLoaded;

  List<Specialty> get data => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$SpecialtiesStateLoadedCopyWith<_$SpecialtiesStateLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SpecialtiesStateErrorCopyWith<$Res> {
  factory _$$SpecialtiesStateErrorCopyWith(_$SpecialtiesStateError value,
          $Res Function(_$SpecialtiesStateError) then) =
      __$$SpecialtiesStateErrorCopyWithImpl<$Res>;
  $Res call({Failure failure});
}

/// @nodoc
class __$$SpecialtiesStateErrorCopyWithImpl<$Res>
    extends _$SpecialtiesStateCopyWithImpl<$Res>
    implements _$$SpecialtiesStateErrorCopyWith<$Res> {
  __$$SpecialtiesStateErrorCopyWithImpl(_$SpecialtiesStateError _value,
      $Res Function(_$SpecialtiesStateError) _then)
      : super(_value, (v) => _then(v as _$SpecialtiesStateError));

  @override
  _$SpecialtiesStateError get _value => super._value as _$SpecialtiesStateError;

  @override
  $Res call({
    Object? failure = freezed,
  }) {
    return _then(_$SpecialtiesStateError(
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$SpecialtiesStateError implements SpecialtiesStateError {
  const _$SpecialtiesStateError({required this.failure});

  @override
  final Failure failure;

  @override
  String toString() {
    return 'SpecialtiesState.error(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpecialtiesStateError &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$$SpecialtiesStateErrorCopyWith<_$SpecialtiesStateError> get copyWith =>
      __$$SpecialtiesStateErrorCopyWithImpl<_$SpecialtiesStateError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Specialty> data) loaded,
    required TResult Function(Failure failure) error,
  }) {
    return error(failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
  }) {
    return error?.call(failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Specialty> data)? loaded,
    TResult Function(Failure failure)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpecialtiesStateInitial value) initial,
    required TResult Function(SpecialtiesStateLoading value) loading,
    required TResult Function(SpecialtiesStateLoaded value) loaded,
    required TResult Function(SpecialtiesStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpecialtiesStateInitial value)? initial,
    TResult Function(SpecialtiesStateLoading value)? loading,
    TResult Function(SpecialtiesStateLoaded value)? loaded,
    TResult Function(SpecialtiesStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class SpecialtiesStateError implements SpecialtiesState {
  const factory SpecialtiesStateError({required final Failure failure}) =
      _$SpecialtiesStateError;

  Failure get failure => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$SpecialtiesStateErrorCopyWith<_$SpecialtiesStateError> get copyWith =>
      throw _privateConstructorUsedError;
}
